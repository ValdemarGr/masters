%! Author = valde
%! Date = 9/13/20

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage{minted}

% Document
\begin{document}
    \section{Combinator backend}
    \subsection{G-machine}
    \begin{itemize}
        \item Gofer language, implementation of haskell.
        \item Originally compiler for ML-language.
        \item Uses super combinators.
        \item Close to Miranda.
        \item S \& K, also others but can be expressed in S and K.
    \end{itemize}
    \subsubsection{Super combinator}
    Either a constant or a combinator.
    \begin{minted}{haskell}
        data NArtiyLambda a where
        End :: b -> a
        Step :: b -> NArtiyLambda a
        data SuperCombinator a where
        Const :: a -> SuperCombinator a
        Combinator :: NArtiyLambda a -> SuperCombinator a
    \end{minted}
    Any lambda calculus expr can be converted to SuperCombinator with \textit{lambda lifting}.
    The technique is basically explicitly parameterizing it instead of closure.

    \section{Bytecode backend}
    \subsubsection{ZINC}
    \begin{itemize}
        \item OCaml backend.
        \item http://caml.inria.fr/pub/papers/xleroy-zinc.pdf
    \end{itemize}
    \begin{itemize}
        \item LLVM official guide for ocaml language implementation, pure ocaml.
        \item Complete compiler.
        \item https://llvm.org/docs/tutorial/OCamlLangImpl1.html
    \end{itemize}

    \section{Emit code}
    \begin{itemize}
        \item Emit C/C++ code.
        \item Implementation easy.
        \item Dont worry about bytecode level performance.
    \end{itemize}

    \section{Syntax}
    \begin{minted}{ocaml}
        import std;
        import util -> u;

        let main =
        let a = 2;

        let b = a + 4;

        std.print a;
        import std.*;
        print b;
    \end{minted}
\end{document}