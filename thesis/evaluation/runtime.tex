\documentclass[11pt,oneside,a4paper]{report}

\begin{document}

\section{Evaluation strategies}
When evaluating the untyped lambda calculus one has to choose an evaluation strategy.
The choice of evaluation strategy has a large impact on aspects such as complexity guarantees.
The names of such strategies are \textit{call by value}, \textit{call by name} and \textit{call by need}.
The call by value is most often the simplest and most natural way of assuming program execution.
\begin{lstlisting}[language=ML,caption={Program that doubles values},label={lst:callbyvalue},mathescape=true]
fun double x = x + x;
let a = double 10;
double (double 10);
\end{lstlisting}
By the call by value semantics, \autoref{lst:callbyvalue} eagerly evaluates every expression.
Clearly the variable \texttt{a} is never used but under the call by value semantics everything is eagerly evaluated.
Every expression is evaluated in logical order in the call by value evaluation strategy.
\begin{figure}[ht]
\begin{lstlisting}[language=ML,caption={Implementation of call by name},label={lst:callbyname},mathescape=true]
fun suspend x unit = x;
fun force x = x 0;
let value = suspend 10;
fun double x = 
    fun susExpensiveOp unit = 
        (force x) + (force x);
    susExpensiveOp;
let a = double value;
force (double value);
\end{lstlisting}
\end{figure}
The call by name semantics however does only evaluate expressions once they are needed (also commonly called \textit{lazy evaluation}).
By the call by name semantics \texttt{a} is never evaluated since it is never used.
In \autoref{lst:callbyname} call by name has been implemented by the use of various functions such as the two constant functions \texttt{suspend} and \texttt{force}.
\texttt{susExpensiveOp} ensures that the forcing (evaluation) of \texttt{x} never occurs until the caller of \texttt{double} forces the result.
By the aforementioned semantics of call by name in the context of the program in \autoref{lst:callbyname} \texttt{a} is never forced thus the computation is never performed.
The implementation of call by name can become quite troublesome and therefore in most cases is a part of the native execution environment which will be discussed in \autoref{tbd}.

The call by need semantics introduces the same lazy evaluation semantics as the call by name strategy but with one extra detail named \textit{sharing}.
In \autoref{lst:callbyname} \texttt{force x} is performed twice which may be an expensive operation.
Under call by need all non side-effectful operations' results are saved for later use similar to techniques such as dynamic programming.
\begin{figure}
    \begin{mdframed}[style=style2]
    \centering
    \begin{subfigure}[b]{0.33\textwidth}
        \centering
    \begin{tikzpicture}
        \node[circle, draw=black] (force) {\texttt{force}};

        \node[circle, draw=black, below = of force] (double) {\texttt{double}};

        \node[circle, draw=black, below = of double] (value) {\texttt{value}};

        \path[->] (force) edge node[left] {} (double);
        \path[->] (double) edge node[left] {} (value);
    \end{tikzpicture}
        \caption{The last expression of the program.}
        \label{sub:eval:main}
    \end{subfigure}
    \begin{subfigure}[b]{0.66\textwidth}
        \centering
    \begin{tikzpicture}
        \node[circle, draw=black] (lamx) {$\lambda \texttt{x}$};

        \node[circle, draw=black, below = of lamx] (lamunit) {$\lambda \texttt{unit}$};

        \node[circle, draw=black, below = of lamunit] (addition) {$+$};

        \node[circle, draw=black, below left = of addition] (force1) {\texttt{force}};
        \node[circle, draw=black, below = of force1] (x1) {\texttt{x}};
        
        \node[circle, draw=black, below right = of addition] (force2) {\texttt{force}};
        \node[circle, draw=black, below = of force2] (x2) {\texttt{x}};

        \path[->] (lamx) edge node[left] {} (lamunit);
        \path[->] (lamunit) edge node[left] {} (addition);

        \path[->] (addition) edge node[left] {} (force1);
        \path[->] (addition) edge node[left] {} (force2);

        \path[->] (force1) edge node[left] {} (x1);
        \path[->] (force2) edge node[left] {} (x2);
    \end{tikzpicture}
        \caption{The expression tree for \texttt{double}}
        \label{sub:eval:double}
    \end{subfigure}
    \end{mdframed}
    \caption{}
    \label{fig:evalexpr}
\end{figure}
To understand this better observe the expression tree for \autoref{lst:callbyname} in \autoref{fig:evalexpr}.
Clearly the right and left branches in \autoref{sub:eval:double} are identical thus they may be memoized such that the forcing of \texttt{x} only occurs once.
More generally if the execution environment supports lazy evaluation, once an expression has been forced it is remembered if that branch is executed again.

\section{Runtime environments}
Now that the untyped lambda calculus has been introduced, implemented and validated efficiently the question of execution naturally follows.
There exists many different well understood strategies to implement an execution environment for the untyped lambda calculus.

One of the most prominent techniques for evaluating functional programs is that of \textit{combinator graphs reductions}.
\begin{align}
    x \label{eq:comb:x}\\
    F \label{eq:comb:F}\\
    Y E \label{eq:comb:app}
\end{align}
There are three types of terms in combinator logic; the variable much like the lambda calculus (\autoref{eq:comb:x}), application (\autoref{eq:comb:app}) and the combinator (\autoref{eq:comb:F}).
The SKI calculus is a very simple set of combinators which are powerful enough to be turing complete and translate to and from the lambda calculus.
In SKI $F = S \,\,|\,\, $
Formally a combinator is a function that has no free variables.
More specifically the combinators


\end{document}
