\documentclass[11pt,oneside,a4paper]{report}

\begin{document}

\section{Evaluation strategies}
When evaluation the untyped lambda calculus one has to choose an evaluation strategy.
The choice of evaluation strategy has a large impact on aspects such as complexity guarantees.
The names of such strategies are \textit{call by value}, \textit{call by name} and \textit{call by need}.
The call by value is the default and simplest semantics implemented in languages.
\begin{lstlisting}[language=ML,caption={Program that doubles values},label={lst:callbyvalue},mathescape=true]
fun double x = x + x;
let a = double 10;
double (double 10);
\end{lstlisting}
By the call by value semantics, \autoref{lst:callbyvalue} eagerly evaluates every expression.
Clearly the variable \texttt{a} is never used but under the call by value semantics everything is eagerly evaluated.
Ever expression is evaluated in logical order.
\begin{lstlisting}[language=ML,caption={Implementation of call by name},label={lst:callbyname},mathescape=true]
fun suspend x unit = x;
fun force x = x 0;
let value = suspend 10;
fun double x = suspend ((force x) + (force x));
force (double value);
\end{lstlisting}
The call by name semantics however does only evaluate expressions once they are needed.
By the call by name semantics \texttt{a} is never evaluated.



\end{document}
