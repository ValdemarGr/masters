\chapter{Conclusions}
In \autoref{sec:prog} we introduced the source language and presented strategies for conversion from high-level languages to the untyped lambda calculus. 
We then introduced types, polymorphism, how to implement a decidable type system and the apparent cost of type systems in \autoref{sec:types}, after which we then gave a brief introduction of the map of type systems.
When a program has been translated and proven, we then sought to determine what the program would evaluate by considering various evaluation strategies and machines \autoref{sec:eval}.
Finally, we gave a brief overview in \autoref{sec:datastruct} of the data structures used to implement the algorithms presented in this work.

\section{Functional programming languages}
Functional programming has throughout time been present in academic circles more often than the industry, whilst imperative has had a big presence in the industry.
As of the time of this thesis, functional programming has been on the rise in mainstream languages.
Various imperative programming languages have introduced concepts, that had otherwise only been found in functional programming languages.
As time progresses, the trend points towards a unification of what previously was considered orthogonal styles, functional and imperative.

